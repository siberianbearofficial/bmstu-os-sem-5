# Процессы в UNIX

## fork()

**fork()** — системный вызов создаёт новый процесс (потомок). Потомок наследует код предка, дескрипторы открытых файлов, сигнальную маску, маску режима создания файлов и т. п.

Вновь созданный процесс — это копия предка, но с собственным адресным пространством (АП).

В современных системах АП виртуальны и защищены.

ВАП реализованы с помощью таблиц страниц (в современных ОС).

Защищенные — значит, система контролирует, чтобы ни один процесс не мог обратиться в АП другого процесса.

**Система контролирует выход процесса за собственное АП!**

В старых системах в АП потомка копировался код предка, в итоге в памяти существовало несколько копий одной программы.

В современных системах используется оптимизированный `fork()`.

### Оптимизированный fork()

Оптимизированный fork работает так же, но дескрипторы таблиц страниц потомка ссылаются на страницы АП предка. При этом для страниц АП предка права доступа меняются на *only read* для сегмента данных и сегмента стека и устанавливается флаг **copy-on-write**.

В результате, если предок или потомок пытаются изменить какую-либо страницу, возникает исключение по правам доступа. В результате обработки этого исключения обнаруживается установленный флаг copy-on-write и выполняются действия по созданию копии страницы для того процесса, который попытался её изменить.

В результате создаются копии только нужных страниц.

Такая ситуация в системе действует до тех пор, пока потомок не вызовет `exec()` или `exit()`. В результате этого вызова у процесса предка права доступа меняются на обычные, и флаг copy-on-write сбрасывается.

---

## exec()

**exec()** — переводит процесс на **новое адресное пространство**. Говорят "создает низкоуровневый процесс". Так говорят, потому что `exec()` **не создаёт новый процесс**, но для программы, которая перед `exec` в качестве параметра создает АП, т.е. таблицы страниц.

> Примечание: `exec` не «принимает АП параметром» — АП создаёт/настраивает ядро по файлу и аргументам `exec*`.

### Основные этапы exec()

У Вахалии 12 пунктов, мы скажем несколько короче.

1. Проверяется путь к файлу, существует ли данный файл. Определить, существует ли данный файл, можно только последовательно пройдя по всем элементам пути.

> Примечание: на практике ядро разрешает путь по компонентам; формулировку «только последовательно пройдя по всем элементам пути» можно понимать как «последовательно по компонентам».

2. Проверяется, может ли процесс, вызвавший `exec`, выполнить этот код, есть ли соответствующие права:
   - есть ли полномочия;
   - проверка заголовка, является ли файл исполняемым (для Unix расширение значения не имеет).

> Примечание: это упрощённо; реальные проверки зависят от ОС (в т. ч. `noexec`, монтирования, политик безопасности и т. п.).

3. Т.к. `fork()` создал для потомка таблицы страниц, была выделена область своппинга - ресурсы надо освободить.

4. Создаются новые карты трансляции адресов (в наших системах таблицы страниц создаются заново).

5. У новых таблицах, очевидно, есть адрес. В дескрипторе процесса есть указатель на адресное пространство (в `task_struct` это mm). Этот указатель на адресное пространство процесса необходимо заменить на адрес новых таблиц страниц.

6. Инициализируется контекст: все регистры - значение `0`, в счетчик команд записывается адрес точки входа. В регистр CR3 необходимо загрузить новый адрес корневой таблицы страниц.

> Примечание: упоминание **CR3** — это частный случай для **x86** (аппаратный регистр базы таблиц страниц). В других архитектурах механизм иной, но идея та же: процесс начинает работу в новом АП.

---

## Программные каналы (pipe)

Программные каналы бывают двух типов:
1. Именованные
2. Неименованные

Мы в ЛР1 создавали именованный программный канал и видели, что у него есть имя, т. е. ПК можно увидеть в файловой системе — он поддерживается файловой подсистемой.

Неименованные ПК создаются с помощью `pipe()`. У них нет имени, но есть файловый дескриптор.

В 4ой программе мы создаем программный канал, каждый из `child` пишет своё сообщение, а `parent` читает 3 раза. Создаётся массив строк, `child` записывает своё сообщение, `parent` читает.

Программный канал — «труба».

`pipe` — «труба». Цилиндр, полый с двух концов. Вода течёт в одну сторону.

С точки зрения программиста — потоковая передача данных.

Для именованных каналов — это специальный файл.

Для неименованных — тоже специальный файл.

Если сообщение получено, оно перестаёт существовать в трубе.

`pipe` — это буфер размером **4096 байт**.

> Примечание: размер **не фиксирован 4096 байт** и зависит от ОС/настроек (в Linux обычно существенно больше; также важна константа `PIPE_BUF` для атомарных записей).

Поскольку pipe имеет ограниченный размер, система контролирует, есть ли процесс, который выбирает данные из буфера — в нашем случае читает. Если такого нет — процесс, пишущий в буфер, будет заблокирован.

> Примечание: формулировка «если такого нет — писатель будет заблокирован» верна только для случая *есть читатель, но не читает*; при *полном отсутствии читателей* поведение другое (SIGPIPE/EPIPE).

Если в трубу записаны сообщения, то они будут там существовать до тех пор, пока не будут прочитаны.

«Если потомок наследует код предка, а предок многопоточный, что унаследует потомок?» — в мануале надо посмотреть:

> После вызова `fork()` в многопоточной программе дочерний процесс имеет один поток, который является точной копией того, что вызвал `fork()`. Наследуется также всё виртуальное адресное пространство.

---

## Сигналы (Signals)

Сигналы — программное средство, с помощью которого процессы UNIX информируются о наступлении событий как в системе, так и в самом процессе.

Сигналы связаны с определёнными событиями. Если это внешние по отношению к процессу события — это **асинхронные** события, возникающие независимо от того, что процесс выполняет.

События, возникающие в самом процессе, **часто являются синхронными**.

> Примечание: в конспекте было «тоже асинхронные» — это типичная путаница. В учебной практике различают *async* (внешние/независимые) и *sync* (ошибки выполнения) сигналы.

Как правило, получив сигнал, процесс должен завершиться, но процесс может сам определить свою реакцию на сигнал.

Процесс может сам определить свою реакцию на сигнал и может:
1. Проигнорировать сигнал
2. Выполнить действие по умолчанию (способом, установленным в системе)
3. Определить своё поведение, т. е. как он будет реагировать на сигнал, включив в код обработчик сигнала.

В примере: в первый раз на сигнал вешается обработчик. Обработчик называется `handler`.

Классический перечень сигналов (UNIX для DDP11). В этом UNIX не могло быть больше 20 сигналов.

Сигналы в UNIX — мощнейшее средство для управления процессами с помощью асинхронных событий.

Сигналы входят в IPC System V Inter Processes Communication (средства межпроцессного взаимодействия).

> Примечание: **System V IPC** обычно включает **семафоры, очереди сообщений и разделяемую память**. Сигналы и pipe исторически относятся к другим механизмам (хотя тоже используются для взаимодействия процессов).

Средства межпроцессного взаимодействия:
1. Сигналы
2. Семафоры
3. Программные каналы
   - именованные
   - неименованные
4. Сегменты разделяемой памяти
5. Очереди сообщений

---

## POSIX / FIPS

**POSIX FIPS (Federal Information Processing Standard)** — государственный стандарт, принятый в США.

> Примечание: **POSIX** — семейство стандартов IEEE (Portable Operating System Interface). Некоторые профили/версии POSIX в разные годы принимались/профилировались государственными стандартами США (FIPS).

Дело в том, что в результате 10 лет развития появились две коммерчески значимые версии UNIX:
- UNIX System V
- UNIX BSD

Они стали существенно отличаться набором системных вызовов. Из-за этого ПО, написанное под одну версию UNIX, нельзя было запускать под другой.

Чтобы продавать ПО, нужно было покупать лицензию на соответствующую ОС, что стало тормозить развитие программного обеспечения.

Был принят стандарт POSIX.1, который определил около 1000 системных вызовов, чтобы можно было писать переносимое ПО. Это закон для федеральных учреждений.

Позже появился GNU.

---

## Пояснения по task3.c

системному вызову exec передаем свои программы
в них требуется ввод данных (в тех программах,
которые передаем exec)
в print нужно вывести ТОЛЬКО идентификатор процесса:
print("%d - введите размер массива: ", getpid());
при выводе также выводить с идентификатором (ТОЛЬКО идентификатор)

обе программы требуют ввод
квант получает один процесс
выводит на экран запрос ввода
за ним идет scanf (библиотечная функция ввода)
в результате процесс блокируется до окончания ввода
и процесс ТЕРЯЕТ квант
квант получает следующий процесс
квант - это отрезок времени
также выводит процесс ввода, за которым следует scanf
процесс блокируется в ожидании завершения ввода и теряет квант
на экране видим два приглашения ввода
просто потому, что работает терминал
оба процесса блокированы до тех пор, пока не будет выполнен ввод
как выполняется ввод?
в системе определено 2 события: нажатие клавиши и ее отпускание
код нажатой клавиши записывается в буфер клавиатуры
контроллер клавиатуры на контроллер прерывания
посылает сигнал прерывания
в результат процессор, получив вектор прерывания,
переходит к обработчику прерывания
в драйвере клавиатуры есть callback функция
она должна из буфера ядра передать код нажатой клавиши в приложение
заблокировать/разблокировать процесс может ТОЛЬКО ядро
когда процесс заблокирован, он не получает процессорное время -> не выполняется
