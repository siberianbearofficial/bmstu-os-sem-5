Основной алгоритм:
в начале 8 прервывания вызывается субратина
субратина запрещает маскируемые прерывания
перед сбросом таймера также вызывается субратина
что запрещает субратина?
далее сохраняются регистры, которые могут меняться
как будет осуществлен возврат, если нет ip?
не надо писать младшие байты, старшие байты
надо писать младшее слово, старшее слово
далее инкремент младшего слова
как доказать, что в счетчике находится реальное время? (текущее количество тиков)
человек воспринимает время как часы, минуты, секунды
соответственно, тики надо перевести в часы, минуты
есть поправка (связана с точностью определения)
после инкремента счетчика реального времени
нельзя писать счетчик таймера
после идет декремент счетчика времени до отключения моторчика дисковода
каждая операция чтения-записи с дискеты в этот счетчик помещает значение ~= 2 секунды
каждый тик декрементирует этот счетчик
когда в счетчике устанавливается 0
сначала по известному адресу записываются четыре нуля
ноль - сброс, единица - установка
т.е. четыре нуля - сброс (почти все пишут установка)
затем сбрасывается флаг (не очень нравится)
на самом деле сбрасывается 0 - признак работы моторчика дисковода
для драйвера:
- если моторчик крутится, можно сразу читать
- если остановлен, сначала надо раскрутить
далее идет ветвление по флагу pf:
- на вызов int 1ch
- на косвенный вызов (3 команды, которые выполняют 1 действие:
lahf, xchg ah,al, push ax) - сохранение flags
Почему перед вызовом надо сохранить flags?
После 1ch вызов субратины
Дальше в порт 20h подаем 20h - end of interrupt
(сброс контроллера прерываний)
После jmp ставим многоточие и руками дописываем
адрес и команду в конец обработчика прерывания

Субратина (подпрограмма), пишем просто вызов sub_1/sub_2/…:
глобально ей запрещаются маскируемые прерывания
маскируемые прерывания - прерывания, которые приходят на контроллер прерывания
причем там стоит ветвление по флагу направления df или iopl
затем cli - clear (сброс) if
делается по известному адресу [316] в области данных bios,
где находится копия регистра флагов
надо написать маска - сброс if по адресу
перед этим загружается flags sahf - сохранение в ah
а после восстановления lahf - восстановление из ah
перед командой end есть префиксная команда lock
префиксная команда lock делает следующую за ней команду неделимой
прервать выполнение такой команды нельзя
цикл выполнения команды:
-> выборка -> дешифрация -> выполнение ->
и опять
в конце цикла выполнения каждой команды
проверка наличия сигнала INT
процессор проверяет наличие сигнала INT на выделенной ножке
как реализована команда lock аппаратно?
она блокирует локальную шину памяти
НЕ шина данных! это не правильно!
физически шины данных не существует
только шина памяти
шина данных - абстракция
в это время ни одна команда, требующая обращения к памяти, выполниться не может
особенность выполнения команды:
2 обращения к памяти (выполняется долго!)
обращение к памяти (цикл обращения к памяти) - долгая операция
команда and здесь используется для сброса флага if
это важнейший флаг, поскольку запрет прерываний - очень серьезное действие
никакие прерывания выполняться не могут
lock должна выполняться очень дозированно
потому что это отражается на отзывчивости системы
понятие быстродействия системы очень размыто
а отзывчивость понятна
теорема Бема-Якопини (о структурном подходе в программировании):
любой алгоритм может быть представлен структурами трех типов:
следование, ветвление, повторение
for - цикл с предусловием (особенность: явно указан параметр цикла)
на самом деле достаточно только двух структур:
следование и повторение
но это усложнило бы составление алгоритма
ни в одном обработчике прерывания не может быть циклов!
потому что они работают на очень высоком уровне
это очень сильно влияет на загруженность системы
например, сетевая подсистема может быть очень сильно нагружена
есть сетевая карточка, с которой работает спец аппарат прерывание
если оно возникает слишком часто, загруженность системы
становится слишком высокой
в современных системах некоторые прерывания заменяют опросом
чтобы не было такого количества прерываний
основная задача обработчика прерывания - декремент кванта

if усл1:
    if усл2:
        D1
    else:
        D2
else:
    D3

ЛИ ПИСАТЬ НЕ НАДО!!! (установлен ли?)

